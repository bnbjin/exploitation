#include "shroud.h"

#include <stdlib.h>
#include <stdio.h>


int set_packet_filter(pcap_t *pcap_hdl, 
    struct in_addr *target_ip, 
    u_short *ports);

void caught_packet(u_char *user_args, 
    const struct pcap_pkthdr *cap_header, 
    const u_char *packet);
 

libnet_t *g_lnctx = NULL;


int main(int argc, char *argv[])
{
    int res = 0;
    char errbuf[LIBNET_ERRBUF_SIZE] = { 0 };
    char pcerrbuf[PCAP_ERRBUF_SIZE] = { 0 };
    uint32_t target_ip = 0;
    u_short existing_ports[MAX_EXISTING_PORTS];
    char *dev = NULL;
    pcap_t *pcaph = NULL;
    struct data_pass critical_libnet_data = { 0 };

    if ((argc < 2) || (argc > MAX_EXISTING_PORTS+2))
    {
        if (argc > 2)
        {
            printf("Limited to tracking %d existing ports.\n", MAX_EXISTING_PORTS);
        }
        else
        {
            printf("Usage: %s <IP to shroud> [existing ports...]\n", argv[0]);
        }

        exit(0);
    }

    g_lnctx = libnet_init(LIBNET_RAW4_ADV, NULL, errbuf);
    if (!g_lnctx)
        goto lexit;

    target_ip = libnet_name2addr4(g_lnctx, argv[1], LIBNET_RESOLVE);
    if (-1 == target_ip)
        goto lexit;

    for (int i = 2; i < argc; i++)
        existing_ports[i-2] = (u_short)atoi(argv[i]);    
    
    dev = pcap_lookupdev(pcerrbuf);
    if(!dev)
        goto lexit;

    pcaph = pcap_open_live(dev, 128, 1, 0, pcerrbuf);
    if(!pcaph)
        goto lexit;

    libnet_seed_prand(g_lnctx);

    res = set_packet_filter(pcaph, (struct in_addr *)&target_ip, existing_ports);
    if (-1 == res)
        goto lexit;

    critical_libnet_data.libnet_handle = g_lnctx;
    pcap_loop(pcaph, -1, caught_packet, (u_char *)&critical_libnet_data);

lexit:

    if (errbuf[0])
        printf("%s", errbuf);

    if (pcerrbuf[0])
        printf("%s", pcerrbuf);

    if (g_lnctx)
        libnet_destroy(g_lnctx);

    if (pcaph)
        pcap_close(pcaph);

    return 0;
}


/* sets a packet filter to look for established TCP connections to target_ip */
int set_packet_filter(pcap_t *pcap_hdl, 
    struct in_addr *target_ip, 
    u_short *ports) 
{
    struct bpf_program filter;
    char *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)];
    int i=0;

    sprintf(filter_string, "dst host %s and ", inet_ntoa(*target_ip)); // target IP 
    strcat(filter_string, "tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0");

    if (ports[0] != 0) 
    {   // if there is at least one existing port
        str_ptr = filter_string + strlen(filter_string);

        if(ports[1] == 0) // there is only one existing port
            sprintf(str_ptr, " and not dst port %hu", ports[i]);
        else 
        {   // two or more existing ports
            sprintf(str_ptr, " and not (dst port %hu", ports[i++]);

            while(ports[i] != 0) 
            {
                str_ptr = filter_string + strlen(filter_string);
                sprintf(str_ptr, " or dst port %hu", ports[i++]);
            }

        strcat(filter_string, ")"); 
        }
    }

    printf("DEBUG: filter string is \'%s\'\n", filter_string);
    if(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)
    {
        printf("pcap_compile failed");
        return -1;
    }

    if(pcap_setfilter(pcap_hdl, &filter) == -1)
    {
        printf("pcap_setfilter failed");
        return -1;
    }

    return 0;
}

void caught_packet(u_char *user_args, 
    const struct pcap_pkthdr *cap_header, 
    const u_char *packet) 
{
    u_char *pkt_data = NULL;
    struct libnet_ipv4_hdr *IPhdr = NULL;
    struct libnet_tcp_hdr *TCPhdr = NULL;
    struct data_pass *passed = NULL;
    int bcount = 0;
    libnet_ptag_t lntag_ip = 0;
    libnet_ptag_t lntag_tcp = 0;

    passed = (struct data_pass *) user_args; // pass data using a pointer to a struct 
    IPhdr = (struct libnet_ipv4_hdr *) (packet + LIBNET_ETH_H);
    TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);

    lntag_ip = libnet_build_ipv4(LIBNET_TCP_H,        // size of the packet sans IP header 
                    IPTOS_LOWDELAY,                 // IP tos 
                    libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 
                    0,                              // frag stuff 
                    libnet_get_prand(LIBNET_PR8),   // TTL (randomized) 
                    IPPROTO_TCP,                    // transport protocol 
                    0,                              // checksum
                    *((u_long *)&(IPhdr->ip_dst)),  // source IP (pretend we are dst) 
                    *((u_long *)&(IPhdr->ip_src)),  // destination IP (send back to src) 
                    NULL,                           // payload (none) 
                    0,                              // payload length 
                    passed->libnet_handle,          // libnet context
                    lntag_ip);                      // libnet tag 

    lntag_tcp = libnet_build_tcp(htons(TCPhdr->th_dport),// source TCP port (pretend we are dst) 
                    htons(TCPhdr->th_sport),        // destination TCP port (send back to src) 
                    htonl(TCPhdr->th_ack),          // sequence number (use previous ack) 
                    htonl((TCPhdr->th_seq) + 1),    // acknowledgement number (SYN's seq # + 1) 
                    TH_SYN | TH_ACK,                // control flags (RST flag set only) 
                    libnet_get_prand(LIBNET_PRu16), // window size (randomized) 
                    0,                              // checksum
                    0,                              // urgent pointer 
                    LIBNET_TCP_H,                   // total len
                    NULL,                           // payload (none) 
                    0,                              // payload length 
                    passed->libnet_handle,          // libnet context
                    lntag_tcp);                     // libnet tag 

    bcount = libnet_write(passed->libnet_handle);

    if (bcount < LIBNET_IPV4_H + LIBNET_TCP_H)
        printf("Warning: Incomplete packet written.");

    printf("bing!\n");
}
